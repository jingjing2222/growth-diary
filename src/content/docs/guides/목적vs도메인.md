---
title: 목적 vs 도메인
description: 좁은 멘탈 모델을 벗어나 문제를 바라보는 새로운 관점
---

## 목적 지향 사고를 하고 있다는 사실

나는 개발을 할때 아래와 같은 플로우를 갖곤 했다.

> "탭 상태 관리(A)가 필요하다 → Zustand store(B)에서 해결하면 되겠다 → 바로 구현하자"

### 목적 지향 사고의 장점

위와 같은 사고는 문제를 빠르게 해결하기 좋았다.

구체적인 요구사항에 집중해 필요한 것만 구현하므로, 코드가 명확하고 이해하기 쉽다. B(store)를 순수 함수에 가깝게 만든다면, A(기능)와 B의 결합도 문제도 별도로 해결할 수 있으며, B의 응집도도 높아진다.

하지만 이 타이밍에 한 가지 빠뜨린 게 있다: **B라는 도구 자체에 대한 Best Practice를 고려했는가?**

- 탭 상태가 페이지 새로고침 후에도 유지되어야 하는가? → `persist` 미검토
- 다른 기능에서도 이 상태 구조를 재사용할 수 있는가? → `slice` 패턴 미검토
- 상태 변화 히스토리가 필요한가? → `subscribe` + middleware 미검토

### 멘탈 모델의 차이

#### 목적 지향 vs 도메인 중심

- **목적 지향 사고**: 주어진 문제를 빠르게 해결하는 것을 최우선으로 하는 마인드셋
  - "탭을 만들자" → 탭 기능 구현 완료 (좋음) → 끝

  ---

- **도메인 중심 사고**: 문제 영역(domain)의 특성과 맥락을 깊이 있게 이해한 후 설계하는 마인드셋
  - "탭이라는 도메인에서 상태의 라이프사이클은? 어디에 영향을 미치는가?" 고민 후 설계

둘 다 중요하지만, 문제는 **도메인의 특성을 충분히 고려하지 않고 목적만 쫓을 때** 발생한다.

#### 두 가지 마인드셋의 차이

| 마인드셋 | 사고 방식 | 결과 |
|---------|---------|------|
| **목적 지향만 하는 경우** | "탭 상태 필요 → Zustand로 구현 → `const [tab] = useState` 처럼 만들자" | 빠른 구현, 하지만 persist 필요 시 나중에 리팩토링 필요 |
| **도메인+시스템 중심 사고** | "탭 상태는 전역 시스템의 일부 → 새로고침 후에도 유지되어야 하나? → 다른 곳에서 재사용될까?" | 더 넓은 관점, persist/slice 같은 확장 포인트 자연스럽게 고려, 초기 설계 비용 증가 |

### 내가 했던 흐름

```
도메인 문제 발견
  ↓
"탭 상태가 필요하다"
  ↓
"Zustand store로 바로 만들자"
  ↓
구현 (목적만 충족)
```

### 올바른 흐름

```
도메인 문제 발견
  ↓
"탭 상태 관리가 필요하다" (도메인 관점)
  ↓
"이 상태는 앱의 전역 시스템에서 어떤 역할인가?" ← 멘탈 모델 변경 타이밍
  ↓
아키텍처 관점에서 고민:
- 새로고침 후에도 유지되어야 하는가? → persist 검토
- 다른 도메인에서도 재사용될 수 있는가? → slice 검토
- 상태 변화 이력이 필요한가? → middleware 검토
  ↓
구현 (목적 + Best Practice 모두 만족)
```

내가 놓친 부분은 **멘탈 모델을 전환하지 않은 것**이었다.

### 왜 이 스위칭이 중요한가?

#### 1. 관점의 차이가 선택지의 폭을 결정한다

- **목적 관점만**: "탭 기능 구현 완료 → 끝"
  - 떠오르는 선택지: 기본 set/get 정도
  - 미검토: persist, middleware, slice, subscribe

  ---

- **도메인+시스템 관점**: "이 상태는 전역 앱 상태의 일부다"
  - 떠오르는 선택지: persist (새로고침 후 유지?), middleware (추적?), slice (재사용?), subscribe (변화 감지?)
  - 결과: 더 견고한 설계

### 2. 초기 설계 비용 vs 이후 리팩토링 비용

| 시점 | 아키텍처 스위칭 | 결과 |
|-----|--------------|------|
| **초기 설계** | 스위칭 O (사고 비용 ↑) | 이후 유지보수 비용 ↓↓ |
| **초기 설계** | 스위칭 X (사고 비용 0) | 이후 리팩토링 비용 ↑↑↑ |

> "C → B → A로 내려가는 사고는 무겁다.
> 하지만 이걸 안 하면 결국 리팩토링 비용으로 돌아온다."

## 결론

**목적 지향 사고는 좋은 출발점이지만, 아키텍처 사고로의 전환 없이는 완성된 설계가 아니다.**

앞으로는 A를 해결할 때, 다음 세 질문을 자동으로 던지자

1. 이게 정말 필요한 것인가? (도메인)
2. 이 시스템의 일부로서 어떤 역할을 가져야 하는가? (아키텍처) ← 여기 멈추기!
3. 그 역할에 맞는 Best Practice는 무엇인가? (구현)

이 습관이 생기면, persist도 자연스럽게 떠오르고, slice도 떠오르고, middleware도 고려된다.
